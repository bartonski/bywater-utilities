# Exported Variables
export RTUSER="${USER}@bywatersolutions.com"
export RTSERVER=http://ticket.bywatersolutions.com/ # Note trailing slash
export BUGZILLA=bugs.koha-community.org

# TODO: there are references to 'xsel' which aren't portable. Need to
# create $COPY and $PASTE, which can be populated according to OS.

if [ ! -z $EMPLOYER_PATH ]
then
    export PATH="$PATH:${EMPLOYER_PATH}/bin"
fi

# If annon is down, export BYWATER_GATEWAY='echor' in the calling script.
if [ -z $BYWATER_GATEWAY ]
then
    export BYWATER_GATEWAY='annon.bywatersolutions.com'
fi

# Shell Functions

# Checks for the existance of a directory; if it does not exist, creates it.
checkdir() {
    if [ ! -d $1 ]; then
        mkdir -p $1
    fi
}

# Takes rt ticket number as argument, opens ticket in browser.
ticket() {
    local ticket_url="${RTSERVER}Ticket/Display.html?id=${1}"
    echo "$ticket_url"
    xdg-open "$ticket_url"
    sleep 1
    echo
}

# Takes rt ticket number as argument, opens self service view of ticket in browser.
partner_ticket() {
    local partner_url="${RTSERVER}SelfService/Display.html?id=${1}"
    echo "$partner_url"
    xdg-open "$partner_url"
    sleep 1
    echo
}


# look up bug in bugzilla
bug() { xdg-open http://${BUGZILLA}/bugzilla3/show_bug.cgi?id=${1}; sleep 1; echo; }

# 'annon ssh' -- ssh to remote server via annon.
assh() {
    if shortname "$@" > /dev/null
    then
        kohaversion "$@"
    fi
    #ssh $BYWATER_GATEWAY ssh "$@" "egrep \'KOHA_CONF|PERL5LIB|ErrorLog\'" '/etc/apache2/sites-enabled/*'
    time ssh -t $BYWATER_GATEWAY ssh "$@";
}

# 'Straight' assh -- use when you want to keep the integrity of STDIN / STDOUT,
# e.g. $ tar cf - backup.20150719.sql.gz | sassh bwsdev tar xvf -
sassh() { ssh  $BYWATER_GATEWAY ssh "$@"; }

# Copy file from remote server to local /tmp
asshcp() {
    local shortname=$1
    local filepath=$2
    local filename="$( basename $filepath )"
    sassh $shortname cat $filepath > /tmp/$filename
    if [ $! ]
    then
        echo "/tmp/$filename"
    fi
}

# remove host key from annon.
asshrmkey() {
    set -x
    ssh $BYWATER_GATEWAY ssh-keygen -R "$1"
    sleep 2
    time ssh -t $BYWATER_GATEWAY ssh "$1"
    set +x
}

# Look up shortname
shortname() {
    ssh  $BYWATER_GATEWAY ./bin/shortname "$1"
    ssh  $BYWATER_GATEWAY grep "$1" /etc/hosts;
}

# I don't keep that much data locally, so I never use this...
mksupport() { mkdir -p $SUPPORT/$1/files; }

# Not sure what this was for.
append_shortname() {
    local shortname="$1"
    local template="$2"
    local linkfile="$3"
    echo "$template" | sed "s/xxx/$shortname/g" >> $linkfile
}

# Look up site by shortname, output sugar, staff client and opac URLs for that site.
# TODO: put this in a shell script of its own.
sugar()
{
    sugarfile=$HOME/Support/notes/ticketlinks.txt # Global
    local shortname=$1
    local sugarurl="http://sugarcrm.bywatersolutions.com/"
          sugarurl="${sugarurl}index.php?action=UnifiedSearch&module="
          sugarurl="${sugarurl}Home&search_form=false&advanced="
          sugarurl="${sugarurl}false&query_string=$shortname"
    echo "sugar file: $sugarfile"
    if grep -q $shortname $sugarfile
    then
        grep $shortname $sugarfile | cut -d: -f 2-
    else
        if [ ! -x $DISPLAY ]
        then
            firefox "$sugarurl" > /dev/null 2> /dev/null &
        fi
        append_shortname $shortname 'xxx: xxx:' $sugarfile
        append_shortname $shortname 'xxx: Sugar URL: ' $sugarfile
        append_shortname $shortname 'xxx: Staff: ' $sugarfile
        append_shortname $shortname 'xxx: Opac: ' $sugarfile
        vim + $sugarfile
        grep $shortname $sugarfile | cut -d: -f 2-
    fi
}

# Open sugar URL in firefox.
sugarff() {
    local shortname=$1
    local linkfile=$HOME/Support/notes/ticketlinks.txt
    local sugarurl="$(sed -n "/$shortname: Sugar URL: /s/^.*Sugar URL: //p" $linkfile )"
    firefox "$sugarurl" 2> /dev/null &
}

# look up opac URL in 'ticketlinks.txt', open URL in web browser
opacurl () {
    set -x
    local linkfile=$HOME/Support/notes/ticketlinks.txt
    if grep "^${1}\>" $linkfile 2>&1 > /dev/null
    then
        opac="$(grep ^${1}: $linkfile | grep 'Opac' | cut -d ':' -f 3- | sed 's|/$||')"
        url="${opac}/${2}"
        echo $url
        xdg-open $url
    fi
    set +x
}

# look up opac Staff client URL in 'ticketlinks.txt', open URL in web browser
kohaurl () {
    local linkfile=$HOME/Support/notes/ticketlinks.txt
    if grep "^${1}\>" $linkfile 2>&1 > /dev/null
    then
        staffclient="$(grep ^${1}: $linkfile | grep Staff | cut -d ':' -f 3- | sed 's|/$||')"
        url="${staffclient}/${2}"
        echo $url
        xdg-open $url
    fi
}

# open staff client in firefox.
kohaff () {
    local linkfile=$HOME/Support/notes/ticketlinks.txt
    if grep "^${1}\>" $linkfile 2>&1 > /dev/null
    then
        staffclient="$(grep ^${1}: $linkfile | grep Staff | cut -d ':' -f 3- | sed 's|/$||')"
        url="${staffclient}/${2}"
        echo $url
        /usr/bin/firefox $url 2> /dev/null &
    fi
}

# run watchcat remotely.
watchcat() {
    echo "watchcat " "$@"
    ssh $BYWATER_GATEWAY watchcat "$@"
}

# get urls via watchcat
wcaturl() {
    watchcat -tgeturls -k$1
}

# get surgar urls via watchcat
wcatsugar() {
    watchcat -tsugarv -k$1
}

# look up koha version using watchcat.
kohaversion() {
    echo watchcat -tkohav -k$1
    watchcat -tkohav -k$1
}

# koha* and opac* below all open various staff client or opac urls.
# Some of these take additional arguments.
# Usage: (koha*|opac*) SHORTNAME [ARGS]

# Open notices and slips
kohaletter() {
    kohaurl "$1" "cgi-bin/koha/tools/letter.pl"
}

# Open a given syspref
# usage: kohasyspref SHORTNAME SYSPREF
kohasyspref() {
    kohaurl "$1" "cgi-bin/koha/admin/preferences.pl?op=search&searchfield=${2}"
}

# Open intranetuserjs
kohaijs() {
    kohasyspref "$1" "intranetuserjs"
}

# Open opacuserjs
kohaojs() {
    kohasyspref "$1" "opacuserjs"
}

# Open admin page
kohaconf() {
    kohaurl "$1" "cgi-bin/koha/admin/admin-home.pl"
}

# Open circ page
kohacirc() {
    kohaurl "$1" "cgi-bin/koha/circ/circulation-home.pl"
}

# Open borrower page
kohapatron() {
    kohaurl "$1" "cgi-bin/koha/members/members-home.pl"
}

# Open advanced search page
kohasearch() {
    kohaurl "$1" "cgi-bin/koha/catalogue/search.pl"
}

# Virtual shelves (??)
kohalist() {
    kohaurl "$1" "cgi-bin/koha/virtualshelves/shelves.pl"
}

# Add bib page
kohacatalog() {
    kohaurl "$1" "cgi-bin/koha/cataloguing/addbooks.pl"
}

# Authorities
kohaauthorities() {
    kohaurl "$1" "cgi-bin/koha/authorities/authorities-home.pl"
}

# Serials
kohaserials() {
    kohaurl "$1" "cgi-bin/koha/serials/serials-home.pl"
}

# Logout
kohalogout() {
    kohaurl "$1" "cgi-bin/koha/mainpage.pl?logout.x=1"
}

# Acquisitions
kohaacq() {
    echo "*** Log in as bwssupport! ***"
    kohaurl "$1" "cgi-bin/koha/acqui/acqui-home.pl"
}

# Koha reports page
kohareport() {
    kohaurl "$1" "cgi-bin/koha/reports/reports-home.pl"
}

# Start new SQL report
kohanewreport() {
    kohaurl "$1" "cgi-bin/koha/reports/guided_reports.pl?phase=Create%20report%20from%20SQL";
}

# Open a report by number
kohareportnum() {
    kohaurl "$1" "cgi-bin/koha/reports/guided_reports.pl?reports=${2}&phase=Show+SQL";
}

# Koha tools page
kohatools() {
    kohaurl "$1" "cgi-bin/koha/tools/tools-home.pl"
}

# Open a given '.pl' page
# Usage: kohapl SHORTNAME PAGE.pl
kohapl() {
    kohaurl "$1" "cgi-bin/koha/$2"
}

# Open detail page for a given bib
# Usage: kohabib SHORTNAME BIBLIONUMBER
kohabib() {
    kohaurl "$1" "cgi-bin/koha/catalogue/detail.pl?biblionumber=$2"
}

# Export bib as marc
# Usage kohadlbib SHORTNAME BIBLIONUMBER
kohadlbib() {
    kohaurl "$1" "cgi-bin/koha/catalogue/export.pl?format=utf8&op=export&bib=$2"
}

# Self Check Out
opacselfcheck() {
    opacurl "$1" "cgi-bin/koha/sco/sco-main.pl"
}

# Library of congress marc reference.
marcrefrence() {
    xdg-open "http://www.loc.gov/marc/bibliographic/bd${1}.html"
}

# Just because I probably won't remember "opacselfcheck"
kohaselfcheck() {
    opacurl "$1" "cgi-bin/koha/sco/sco-main.pl"
}

# Create comment suitable for adding to crontab. Takes RT ticket number as argument. ouput looks like this:
# 2014-02-07 -- Barton Chittenden -- http://ticket.bywatersolutions.com/Ticket/Display.html?id=18204
croncomment () {
    echo "# $(date +%Y-%m-%d) -- $USER@bywatersolutions.com -- http://ticket.bywatersolutions.com/Ticket/Display.html?id=$1"
}

# Render markdown file using pandoc, put in HOME/public_html/markdown
md() {
    local htmldir="$HOME/public_html/markdown"
    test -d $htmldir || mkdir $htmldir
    local base="$(basename $1 '.markdown')"
    local htmlfile="$htmldir/${base}.html"
    pandoc -f markdown $1 > "$htmlfile"
    echo "$htmlfile"
}

# Render markdown file using pandoc, put in current directory -- useful for blog posts.
bmd ()
{
    local htmldir=".";
    test -d $htmldir || mkdir $htmldir;
    local base="$(basename $1 '.markdown')";
    local htmlfile="$htmldir/${base}.html";
    pandoc -f markdown $1 > "$htmlfile";
    echo "$htmlfile"
}


# show the tables that contain a search term in kohastructure.sql.
grepks ()
{
    egrep --color=auto -i "^(CREATE TABLE|[)])|$1" $KOHA/installer/data/mysql/kohastructure.sql | grep --color=auto -i --color=auto -B1 "$1"
}

# round up to the next multiple of 15 -- used for calculating time to report in RT.
rttime () {
    perl -e '$minutes = $ARGV[0] + 15; $quarter_hours = int($minutes/15); print $quarter_hours*15 . " minutes\n" ' $1
}

# An extension of querymarc, generating actual sql. Needs to be split into two functions.
qm ()
{
    qm="$(querymarc $1)";
    echo "select $qm as '$1' from biblioitems where $qm != '' limit 1;";
    echo "select $qm as '$1', title from biblioitems inner join biblio using (biblionumber) where $qm != '' limit 1;";
    echo "select marcxml from biblioitems where $qm != '' limit 1;"
}

# This was something that I added when I was working on zebra indexing. Pay it very little mind...
# nextrecord 13 20930 gts 'add zebra indexes 260$e, 264$a, 752$a-$h => publisher location' '260$e'
nextrecord ()
{
    bibnum=$1;
    rtnum=$2;
    shortname=$3;
    subject="$4";
    edbib $bibnum;
    t $rtnum $shortname "$subject";
    qm="$(querymarc $5)";
    echo "assh $shortname";
    echo "sudo koha-list";
    echo "ps aux | grep $shortname";
    echo "sudo koha-mysql $shortname";
    echo "select $qm from biblioitems where $qm != '' limit 1;";
    echo "select marcxml from biblioitems where $qm != '' limit 1;"
}

# Crontab entries to schedule 'run_rebuild.sh' -- takes RT ticket number as argument
schedule_rebuild() {
    local ticket=${1}
    local instance=${2}
    echo "# $(date +%Y-%m-%d) -- $USER@bywatersolutions.com -- http://ticket.bywatersolutions.com/Ticket/Display.html?id=$1"
    echo
    echo "# Git"
    date +"# 5 0 %d %m %u /home/koha/run_rebuild.sh" -d tomorrow;
    if [ -z $instance ]
    then
        echo "No instance given"
    else
        echo
        echo "# Package: /etc/cron.d/koha-$instance"
        date +"# 5 0 %d %m %u ${instance}-koha /var/lib/koha/$instance/run_rebuild.sh" -d tomorrow;
        echo
        echo "# Cluster: -- schedule in bywater crontab"
        date +"# 5 0 %d %m %u sudo /home/bywater/run-rebuild-from-bywater.sh $instance" -d tomorrow
    fi
}


# Some sort of date difference thingus -- not sure why.
datediff() {
    later="${1}"
    earlier="${2}"
    echo $(( $(date -d "$later" +%j) - $(date -d "$earlier" +%j) ))
}

# An attempt to figure out which release a bug is in.
bugrelease() {
    git log --oneline | egrep -i "Bug $1|release" | grep --context=10 "Bug $1"
}

# search for terms on bywater wiki.
bwiki() {
    local searchparams="$(sed 's/ \+/+/' <<< "$*")"
    xdg-open "http://wiki.bywatersolutions.com/doku.php?do=search&id=${searchparams}"
}

# Reformat arguments (as copied from IRC) and put them into 'xsel', ready for pasting.
kbticket() { echo "${@}" | sed 's/^.* <samwise> Ticket //; s/(open): //; s/ - http:.*//' | xsel; }


# Today's date, in the format YYYY-MM-DD
today() { local d="$(date --rfc-3339='date')"; echo "Today: $d" ; }

# Daily wrap
dw() {
    checkdir "$EMPLOYER_PATH/daynotes/"
    local notefile="$EMPLOYER_PATH/daynotes/$(date +%Y%m%d).note.txt"
    echo "Daily Wrap-up ( $( date +'%a %b %d, %Y') )"
    sed -n '1,/^---- 1/p' $notefile
    local EOB="$(sed -n '1,/^---- 1/p' $notefile | grep EOB)"
    if [[ ! -z $EOB ]]; then
        echo "Un-closed EOB items:"
        echo "$EOB"
    fi
}

# Telnet to a given domain and port, see if the port is open. The commands to exit telnet
# are left in the copy/paste buffer.
porttest() { echo $'\c]quit' | xsel ; telnet $1 $2; }

#alias lynx='lynx -accept_all_cookies'

# Very similar to 'dw' above. This one is actually used internally in 'daynote'
dn() {
    local notefile=$1
    echo $notefile
    echo
    echo "Daily Wrap-up ( $( date +'%a %b %d, %Y') )"
    sed -n '/^---- Done Today/,/^----/p' $notefile | grep -v '^----'
    local EOB="$(sed -n '/^---- Done Today/,/^----/p' $notefile | grep EOB)"
    if [[ ! -z $EOB ]]; then
        echo "Un-closed EOB items:"
        echo "$EOB"
    fi
    sed -n '/^---- Done Today/,/^----/p' $notefile | stdin_gmtix.pl
}

# Open daily notes. Print wrap-up when vim closes.
daynote() {
    checkdir "$EMPLOYER_PATH/daynotes/"
    local notefile="/home/barton/Employer/bywater/daynotes/$(date +%Y%m%d).note.txt"
    if [[ ! -e $notefile ]]
    then
    cat > $notefile << DAYNOTE
---- Done Today

Linux tip of the day:

What I Learned:

---- My Tickets

---- Personal Notes

---- Queries
-- 
foo
-- 
foo
-- 
foo
-- 
foo
-- 
foo
-- 
foo

---- Scratch
...
...
...

---- What do I do at my desk?

---- What do I want to do that I'm not?

---- What's working

---- What's not working

---- What am I putting off?

---- I have no place to put ...

---- I can't ...

---- I can never find

---- I'm losing a lot of money on ...

---- Disorganization makes me feel ...

---- 
DAYNOTE
    fi
    vim -S $EMPLOYER_PATH/.bywater_vimrc +/"My Tickets" $notefile
    echo
    dn $notefile
}

# Reads argument list containing RT ticket numbers, search for unread emails containing those tickets.
gmtix() {
    perl -E 'say "https://mail.google.com/mail/u/1/#search/(from%3Asupport%40bywatersolutions.com)+is%3Aunread+subject%3A(" . join( "+OR+", @ARGV ) .  ")"' $@;
}

# Look up opac and staff client URLs. (Somewhat) suitable for pasting into vim for 'sugar' above.
kohalinks() {
    watchcat -tgeturls -k$1 | grep http | while read url; do
        local wget_out="$(wget --quiet -O - $url)"
        if [[ $? = 0 ]]; then
            if grep -q 'TEMPLATE FILE: opac-main.tt' <<< "$wget_out"; then
                echo "$1 OPAC: $url"
            else
                echo "$1 Staff: $url"
            fi
        fi
    done | sort -r
}

# Allows you to choose queries listed in the '$SUPPORT_QUERIES' directory and
# gives you the wget line that you can paste into ssh to run the queries via koha-mysql.
# May optionally take an instance name.
sq() {
    (
        cd $SUPPORT_QUERIES
        local INSTANCE=${1}
        local SQLCMD="sudo koha-mysql $INSTANCE"
        select query in *.sql quit; do
            case $query in
                quit)
                    break
                ;;

                *)
                    echo "wget -q -O - http://bywatersolutions.github.io/koha_support_queries/$query | $SQLCMD"
                    break
                ;;
            esac
        done
    )
}
